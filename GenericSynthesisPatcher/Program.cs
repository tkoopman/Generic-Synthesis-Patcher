using System.Collections.Frozen;
using System.Data;

using EnumsNET;

using GenericSynthesisPatcher.Helpers;
using GenericSynthesisPatcher.Json.Data;
using GenericSynthesisPatcher.Json.Operations;

using Microsoft.Extensions.Logging;

using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

using Newtonsoft.Json;

using Noggog;

namespace GenericSynthesisPatcher
{
    public partial class Program
    {
        private const int ClassLogCode = 0x01;
        private static readonly List<(RecordTypes Type, FormKey FormKey, GSPRule Rule, RecordCallData Rcd, int Changes)> RecordUpdates = [];
        private static RecordTypes EnabledTypes;

        public static async Task<int> Main ( string[] args )
        {
            if (args.Length == 0)
            {
                GenerateDoco.Generate();
                return 0;
            }
            else
            {
                return await SynthesisPipeline.Instance
                    .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                    .SetAutogeneratedSettings(nickname: "Generic Synthesis Patcher Settings", path: "settings.json", out Global.settings)
                    .SetTypicalOpen(GameRelease.SkyrimSE, "GenericSynthesisPatcher.esp")
                    .Run(args);
            }
        }

        public static void RunPatch ( IPatcherState<ISkyrimMod, ISkyrimModGetter> state )
        {
            Global.State = state;

            if (Global.Settings.Value.Logging.LogLevel <= LogLevel.Debug)
            {
                LogHelper.WriteLog(LogLevel.Debug, ClassLogCode, "Extra logging for FormKey: " +
                    (
                        Global.Settings.Value.Logging.All ? "ALL" :
                        Global.Settings.Value.Logging.FormKey == FormKey.Null ? "None" :
                        Global.Settings.Value.Logging.FormKey.ToString()
                    ));
            }

            var Rules = LoadRules();
            if (Rules.Count == 0)
                return;

            // subTotals values = (Total, Matched, Updated, Changes)
            SortedDictionary<RecordTypes, Counts> subTotals = [];

            while (EnabledTypes != RecordTypes.NONE)
            {
                IEnumerable<IModContext<ISkyrimMod, ISkyrimModGetter, ISkyrimMajorRecord, ISkyrimMajorRecordGetter>> ProcessTypeRecords;
                if (EnabledTypes.HasFlag(RecordTypes.ALCH))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Ingestible().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.ALCH);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.AMMO))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Ammunition().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.AMMO);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.ARMO))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Armor().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.ARMO);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.BOOK))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Book().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.BOOK);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.CELL))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Cell().WinningContextOverrides(state.LinkCache);
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.CELL);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.CONT))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Container().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.CONT);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.FACT))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Faction().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.FACT);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.INGR))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Ingredient().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.INGR);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.KEYM))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Key().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.KEYM);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.MISC))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().MiscItem().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.MISC);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.NPC))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Npc().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.NPC);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.OTFT))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Outfit().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.OTFT);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.SCRL))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Scroll().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.SCRL);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.WEAP))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Weapon().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.WEAP);
                }
                else if (EnabledTypes.HasFlag(RecordTypes.WRLD))
                {
                    ProcessTypeRecords = state.LoadOrder.PriorityOrder.OnlyEnabledAndExisting().Worldspace().WinningContextOverrides();
                    EnabledTypes = EnabledTypes.RemoveFlags(RecordTypes.WRLD);
                }
                else
                {
                    LogHelper.WriteLog(LogLevel.Critical, ClassLogCode, $"Found unsupported types. {(int)EnabledTypes:B18}");
                    break;
                }

                foreach (var context in ProcessTypeRecords)
                {
                    var recordType = GSPBase.GetGSPRuleType(context.Record);
                    if (subTotals.TryGetValue(recordType, out var counts))
                    {
                        counts.Total++;
                    }
                    else
                    {
                        counts = new Counts(total: 1);
                        subTotals.Add(recordType, counts);
                    }

                    ISkyrimMajorRecord? patchRecord = null;

                    foreach (var rule in Rules)
                    {
                        Global.Processing(ClassLogCode, rule, context);

                        if (rule.Matches(context))
                        {
                            if (rule is GSPRule gspRule)
                            {
                                int changed = ProcessRule(context, gspRule, ref patchRecord);
                                if (changed >= 0) // -1 would mean failed OnlyIfDefault check
                                {
                                    counts.Matched++;
                                    if (changed > 0)
                                        counts.Updated++;
                                    counts.Changes += changed;
                                }
                            }
                            else if (rule is GSPGroup group)
                            {
                                Global.TraceLogger?.Log(ClassLogCode, $"Matched group. Processing Rules.");
                                int count = 0;
                                foreach (var groupRule in group.Rules)
                                {
                                    Global.Processing(ClassLogCode, groupRule, context);

                                    count++;
                                    if (groupRule.Matches(context))
                                    {
                                        int changed = ProcessRule(context, groupRule, ref patchRecord);
                                        if (changed >= 0) // -1 would mean failed OnlyIfDefault check
                                        {
                                            counts.Matched++;
                                            if (changed > 0)
                                                counts.Updated++;
                                            counts.Changes += changed;

                                            if (group.SingleMatch)
                                            {
                                                if (count != group.Rules.Count)
                                                    Global.TraceLogger?.Log(ClassLogCode, $"Skipping remaining rules in group due to SingleMatch. Checked {count}/{group.Rules.Count}");
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Global.Processing(ClassLogCode, null, null);
            LogHelper.WriteLog(LogLevel.Information, ClassLogCode, $"Completed");
            Console.WriteLine();
            LogHelper.PrintCounts();
            Console.WriteLine();

            var updates = RecordUpdates.GroupBy(g => (g.Type, g.FormKey, g.Rcd.PropertyName),
                                                g => (g.Rule, g.Changes), (k, data) => new { Key = k, Rules = data.Select(d => d.Rule).Count(), Changes = data.Select(d => d.Changes).Sum() })
                                       .Where(g => g.Rules > 1);

            foreach (var update in updates)
                Console.WriteLine($"Warning: Record {update.Key.FormKey} had {update.Key.PropertyName} updated by {update.Rules} different rules, with total of {update.Changes} changes.");

            Console.WriteLine();

            Console.WriteLine($"Record Type Totals");
            Console.WriteLine($"{"Type",-10} {"Total",10} {"Matched",10} {"Updated",10} {"Changes",10}");

            var totals = new Counts();

            foreach (var (key, subTotal) in subTotals)
            {
                Console.WriteLine($"{Enum.GetName(key),-10} {subTotal.Total,10:N0} {subTotal.Matched,10:N0} {subTotal.Updated,10:N0} {subTotal.Changes,10:N0}");
                totals.Total += subTotal.Total;
                totals.Matched += subTotal.Matched;
                totals.Updated += subTotal.Updated;
                totals.Changes += subTotal.Changes;
            }

            Console.WriteLine($"{"Totals",-10} {totals.Total,10:N0} {totals.Matched,10:N0} {totals.Updated,10:N0} {totals.Changes,10:N0}");
        }

        private static List<GSPBase> LoadRules ()
        {
            EnabledTypes = RecordTypes.NONE;
            string dataFolder = Global.Settings.Value.Folder;
            dataFolder = dataFolder.Replace("{SkyrimData}", Global.State.DataFolderPath);
            dataFolder = dataFolder.Replace("{SynthesisData}", Global.State.ExtraSettingsDataPath);

            if (!Directory.Exists(dataFolder))
            {
                LogHelper.WriteLog(LogLevel.Error, ClassLogCode, $"Missing data folder: {dataFolder}");
                return [];
            }

            var LoadedRules = new List<GSPBase>();
            int count = 0;

            var files = Directory.GetFiles(dataFolder).Where(x => x.EndsWith(".json"));
            int countFile = 1;
            files.ForEach(f =>
            {
                if (f.Equals(Path.Combine(Global.State.ExtraSettingsDataPath ?? "", "settings.json")))
                {
                    LogHelper.WriteLog(LogLevel.Information, ClassLogCode, $"Skipping: {f}");
                }
                else
                {
                    LogHelper.WriteLog(LogLevel.Information, ClassLogCode, $"Loading config file #{countFile}: {f}");
                    List<GSPBase>? rules = null;
                    using (var jsonFile = File.OpenText(f))
                    {
                        using var jsonReader = new JsonTextReader(jsonFile);
                        rules = JsonSerializer.Create(Global.SerializerSettings).Deserialize<List<GSPBase>>(jsonReader);
                    }

                    int countRule = 1;
                    foreach (var rule in rules ?? [])
                    {
                        rule.ConfigFile = countFile++;
                        rule.ConfigRule = countRule++;

                        if (!rule.Validate())
                        {
                            LogHelper.WriteLog(LogLevel.Critical, ClassLogCode, "Error validating rules.", rule: rule);
                            LoadedRules = [];
                            return;
                        }

                        if (rule is GSPGroup group)
                            count += group.Rules.Count;
                        else
                            count++;

                        if (EnabledTypes == RecordTypes.All)
                            break;

                        if (rule == null)
                            continue;

                        if (rule.Types == RecordTypes.All)
                        {
                            LogHelper.WriteLog(LogLevel.Information, ClassLogCode, "Found rule with no or all defined types. For best performance you should always define at least 1 type, and only required types for the rule.");
                            EnabledTypes = RecordTypes.All;
                        }
                        else
                        {
                            EnabledTypes |= rule.Types;
                        }

                        LoadedRules.Add(rule);
                    }
                }
            });

            if (LoadedRules.Count == 0)
            {
                LogHelper.WriteLog(LogLevel.Error, ClassLogCode, $"No rules found in data location: {dataFolder}");
                return [];
            }

            LoadedRules.Sort();

            if (LoadedRules.Count != count)
                LogHelper.WriteLog(LogLevel.Information, ClassLogCode, $"Loaded {LoadedRules.Count} primary rules and {count} total rules.");
            else
                LogHelper.WriteLog(LogLevel.Information, ClassLogCode, $"Loaded {count} total rules.");

            return LoadedRules;
        }

        private static int ProcessFillRecord ( IModContext<ISkyrimMod, ISkyrimModGetter, ISkyrimMajorRecord, ISkyrimMajorRecordGetter> context, IMajorRecordGetter? origin, GSPRule rule, FilterOperation valueKey, ref ISkyrimMajorRecord? patchRecord )
        {
            if (context.Record is not IMajorRecordGetter)
            {
                Global.DebugLogger?.LogInvalidTypeFound(ClassLogCode, "", typeof(IMajorRecordGetter).Name, context.Record.GetType().Name);
                return -1;
            }

            var rcd = RCDMapping.FindRecordCallData(context, valueKey.Value);
            if (rcd == null || !rcd.CanFill())
            {
                Global.TraceLogger?.Log(ClassLogCode, $"Unknown / Unimplemented field for fill action: {valueKey.Value}");
                return -1;
            }

            if (rule.OnlyIfDefault && !rcd.Matches(context.Record, origin, rcd))
            {
                Global.TraceLogger?.Log(ClassLogCode, LogHelper.OriginMismatch, propertyName: rcd.PropertyName);
                return -1;
            }

            int changed = rcd.Fill(context, rule, valueKey, rcd, ref patchRecord);

            if (changed > 0)
                RecordUpdates.Add((GSPBase.GetGSPRuleType(context.Record), context.Record.FormKey, rule, rcd, changed));

            return changed;
        }

        private static int ProcessForwardRecord ( IModContext<ISkyrimMod, ISkyrimModGetter, ISkyrimMajorRecord, ISkyrimMajorRecordGetter> context, IMajorRecordGetter? origin, GSPRule rule, FilterOperation valueKey, ref ISkyrimMajorRecord? patchRecord )
        {
            if (context.Record is not IMajorRecordGetter)
            {
                Global.DebugLogger?.LogInvalidTypeFound(ClassLogCode, "", typeof(IMajorRecordGetter).Name, context.Record.GetType().Name);
                return 0;
            }

            if (!rule.TryGetForward(valueKey, out var mods, out string[]? fields))
                return -1;

            var All = Global.State.LinkCache.ResolveAllContexts(context.Record.FormKey, context.Record.Registration.GetterType);
            if (!All.SafeAny())
                return -1;

            var orderedMods = mods.Select((key,value) => new { key = key.Key, value = All.FirstOrDefault(m => m.ModKey.Equals(key.Key)) }).ToFrozenDictionary(x => x.key, x => x.value);

            if (!orderedMods.Any(k => k.Value != null))
                return -1;

            int changed = 0;
            foreach (string field in fields)
            {
                var rcd = RCDMapping.FindRecordCallData(context, field);
                if (rcd == null || !rcd.CanForward() || (rule.ForwardType.HasFlag(ForwardTypes.SelfMasterOnly) && !rcd.CanForwardSelfOnly()))
                {
                    Global.TraceLogger?.Log(ClassLogCode, $"Unknown / Unimplemented field for forward action type: {Enum.GetName(rule.ForwardType)}", propertyName: field);
                    continue;
                }

                bool firstMod = true;

                if (rule.HasForwardType(ForwardTypeFlags.SelfMasterOnly))
                {
                    foreach (var mod in orderedMods)
                    {
                        Global.TraceLogger?.Log(ClassLogCode, $"Attempt {Enum.GetName(rule.ForwardType)} forward field {field} from {mod.Key}");
                        if (rule.ForwardType.HasFlag(ForwardTypes.DefaultThenSelfMasterOnly))
                        {
                            if (firstMod)
                            {   // First mod of DefaultThenSelfMasterOnly
                                if (mod.Value == null) // We don't continue if first mod can't be default forwarded
                                    break;

                                if (rule.OnlyIfDefault && !rcd.Matches(context.Record, origin, rcd))
                                {
                                    Global.TraceLogger?.Log(ClassLogCode, LogHelper.OriginMismatch, propertyName: rcd.PropertyName);
                                    break;
                                }

                                int changes = rcd.Forward(context, rule, mod.Value, rcd, ref patchRecord);
                                if (changes < 0)
                                {   // If default forward fails we do not continue with the SelfMasterOnly forwards
                                    Global.TraceLogger?.Log(ClassLogCode, "DefaultThenSelfMasterOnly: Default forward failed so skipping SelfMasterOnly mods.");
                                    break;
                                }
                                else
                                {
                                    changed += changes;
                                    firstMod = false;
                                }
                            }
                            else
                            {   // All other mods in DefaultThenSelfMasterOnly - No need to check origin
                                int changes = (mod.Value != null)?rcd.ForwardSelfOnly(context, rule, mod.Value, rcd, ref patchRecord): 0;
                                if (changes > 0)
                                    changed += changes;
                            }
                        }
                        else if (rule.ForwardType.HasFlag(ForwardTypes.SelfMasterOnly))
                        {   //  SelfMasterOnly
                            if (patchRecord != null && rule.OnlyIfDefault && !rcd.Matches(context.Record, origin, rcd))
                            {
                                Global.TraceLogger?.Log(ClassLogCode, LogHelper.OriginMismatch, propertyName: rcd.PropertyName);
                                break;
                            }

                            // modContext == null fine here we just skip those ones
                            int changes = (mod.Value != null)?rcd.ForwardSelfOnly(context, rule, mod.Value, rcd, ref patchRecord): 0;
                            if (changes > 0)
                                changed += changes;
                        }
                        else
                        {   // Should never reach here as Default already handled outside of foreach loop.
                            throw new Exception("WTF. Code should never reach this point.");
                        }
                    }
                }
                else
                {   // Default Forward Type
                    var filtered = orderedMods.Where(x => x.Value != null).ToList(); // This will always return at least 1 entry due to previous checks
                    int index = filtered.Count != 1 && rule.HasForwardType(ForwardTypeFlags.Random) ? new Random(HashCode.Combine(context.Record.FormKey, rcd.PropertyName, rule)).Next(filtered.Count) : 0;

                    if (filtered.Count > 1)
                        Global.TraceLogger?.Log(ClassLogCode, $"Method: {Enum.GetName(rule.ForwardType)}. Selected #{index + 1} from {filtered.Count} available mods.", propertyName: rcd.PropertyName);

                    var modContext = filtered.ElementAt(index);
                    Global.TraceLogger?.Log(ClassLogCode, $"Default forwarding from: {modContext.Key.FileName}", propertyName: rcd.PropertyName);

                    if (rule.OnlyIfDefault && !rcd.Matches(context.Record, origin, rcd))
                    {
                        Global.TraceLogger?.Log(ClassLogCode, LogHelper.OriginMismatch, propertyName: rcd.PropertyName);
                    }
                    else
                    {
                        int changes = (modContext.Value != null) ? rcd.Forward(context, rule, modContext.Value, rcd, ref patchRecord) : throw new Exception("WTF Should never hit this!");
                        if (changes > 0)
                            changed += changes;
                    }
                }

                if (changed > 0)
                    RecordUpdates.Add((GSPBase.GetGSPRuleType(context.Record), context.Record.FormKey, rule, rcd, changed));
            }

            return changed;
        }

        private static int ProcessMergeRecord ( IModContext<ISkyrimMod, ISkyrimModGetter, ISkyrimMajorRecord, ISkyrimMajorRecordGetter> context, IMajorRecordGetter? origin, GSPRule rule, FilterOperation valueKey, ref ISkyrimMajorRecord? patchRecord )
        {
            var rcd = RCDMapping.FindRecordCallData(context, valueKey.Value);
            if (rcd == null || !rcd.CanMerge())
            {
                Global.TraceLogger?.Log(ClassLogCode, $"Unknown / Unimplemented field for merge action: {valueKey.Value}");
                return -1;
            }

            if (rule.OnlyIfDefault && !rcd.Matches(context.Record, origin, rcd))
            {
                Global.TraceLogger?.Log(ClassLogCode, LogHelper.OriginMismatch, propertyName: rcd.PropertyName);
                return -1;
            }

            Global.TraceLogger?.Log(ClassLogCode, $"Merging field.", propertyName: rcd.PropertyName);
            int changed = rcd.Merge(context, rule, valueKey, rcd, ref patchRecord);

            if (changed > 0)
                RecordUpdates.Add((GSPBase.GetGSPRuleType(context.Record), context.Record.FormKey, rule, rcd, changed));

            return changed;
        }

        private static int ProcessRule ( IModContext<ISkyrimMod, ISkyrimModGetter, ISkyrimMajorRecord, ISkyrimMajorRecordGetter> context, GSPRule rule, ref ISkyrimMajorRecord? patchRecord )
        {
            // We want result to be 0 if no actions so it works with SingleMatch
            if (!rule.Fill.SafeAny() && !rule.Forward.SafeAny() && !rule.Merge.SafeAny())
            {
                Global.TraceLogger?.Log(ClassLogCode, "Rule contains no actions.");
                return 0;
            }

            int changes = -1;

            var origin = rule.OnlyIfDefault ? Mod.FindOrigin(context) : null;

            if (rule.Merge.Count > 0)
            {
                int versions = Global.State.LinkCache.ResolveAllContexts(context.Record.FormKey, context.Record.Registration.GetterType).Count();
                switch (versions)
                {
                    case < 2:
                        Global.TraceLogger?.Log(ClassLogCode, "Doesn't have any overwrites to merge with.");
                        break;

                    default:
                        foreach (var x in rule.Merge)
                        {
                            int changed = ProcessMergeRecord(context, origin, rule, x.Key, ref patchRecord);

                            if (changed >= 0)
                                changes = (changes == -1) ? changed : changes + changed;
                        }

                        break;
                }
            }

            foreach (var x in rule.Forward)
            {
                int changed = ProcessForwardRecord(context, origin, rule, x.Key, ref patchRecord);

                if (changed >= 0)
                    changes = (changes == -1) ? changed : changes + changed;
            }

            foreach (var x in rule.Fill)
            {
                int changed = ProcessFillRecord(context, origin, rule, x.Key, ref patchRecord);

                if (changed >= 0)
                    changes = (changes == -1) ? changed : changes + changed;
            }

            return changes;
        }
    }
}