using System.Data;

using GenericSynthesisPatcher.Helpers;
using GenericSynthesisPatcher.Rules;
using GenericSynthesisPatcher.Rules.Loaders;

using Loqui;

using Microsoft.Extensions.Logging;

using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Synthesis;

namespace GenericSynthesisPatcher
{
    public partial class Program
    {
        /// <summary>
        ///     Record of all record properties that have been updated. Used to detect when a
        ///     property is updated by 2 or more different actions / rules.
        /// </summary>
        /// TODO: Currently if property that includes sub-properties is changed twice once at main and then at sub-property it won't be shown as a warning
        internal static readonly List<(ILoquiRegistration Type, FormKey FormKey, GSPRule Rule, string Property, int Changes)> RecordUpdates = [];

        private const int ClassLogCode = 0x01;

        // subTotals values = (Total, Matched, Updated, Changes)
        private static readonly SortedDictionary<string, Counts> SubTotals = [];

        public static async Task<int> Main (string[] args)
        {
            if (args.Length == 0)
                return -1;

            //TODO Add games
            return await SynthesisPipeline.Instance
                                .AddPatch<Mutagen.Bethesda.Skyrim.ISkyrimMod, Mutagen.Bethesda.Skyrim.ISkyrimModGetter>(RunPatch)
                                .AddPatch<Mutagen.Bethesda.Fallout4.IFallout4Mod, Mutagen.Bethesda.Fallout4.IFallout4ModGetter>(RunPatch)
                                .AddPatch<Mutagen.Bethesda.Oblivion.IOblivionMod, Mutagen.Bethesda.Oblivion.IOblivionModGetter>(RunPatch)
                                .SetAutogeneratedSettings(nickname: "Generic Synthesis Patcher Settings", path: "settings.json", out Global.LazySettings)
                                .SetTypicalOpen(GameRelease.SkyrimSE, "GenericSynthesisPatcher.esp")
                                .Run(args);
        }

        public static void RunPatch (IPatcherState<Mutagen.Bethesda.Skyrim.ISkyrimMod, Mutagen.Bethesda.Skyrim.ISkyrimModGetter> state)
        {
            Global.Initialize(state);
            RunPatch();
        }

        public static void RunPatch (IPatcherState<Mutagen.Bethesda.Fallout4.IFallout4Mod, Mutagen.Bethesda.Fallout4.IFallout4ModGetter> state)
        {
            Global.Initialize(state);
            RunPatch();
        }

        public static void RunPatch (IPatcherState<Mutagen.Bethesda.Oblivion.IOblivionMod, Mutagen.Bethesda.Oblivion.IOblivionModGetter> state)
        {
            Global.Initialize(state);
            RunPatch();
        }

        public static void RunPatch ()
        {
            if (Global.Settings.Logging.LogLevel <= LogLevel.Debug)
            {
                Global.Logger.WriteLog(LogLevel.Debug, LogType.GeneralConfig, "Extra logging for FormKey: " +
                    (
                        Global.Settings.Logging.All ? "ALL" :
                        Global.Settings.Logging.FormKey == FormKey.Null ? "None" :
                        Global.Settings.Logging.FormKey.ToString()
                    ), ClassLogCode);
            }

            List<GSPBase> Rules = [];
            List<IGSPConfigs> Loaders = [];
            if (!Global.Settings.LoadGSPConfigs)
            {
                Global.Logger.WriteLog(LogLevel.Information, LogType.CONFIG, "Loading of GSP JSON config files is disabled in settings.", ClassLogCode);
            }
            else
            {
                var loader = new GSPJson();
                Loaders.Add(loader);

                if (loader.LoadRules(1))
                {
                    Rules.AddRange(loader.Rules);
                }
                else
                {
                    Global.Logger.WriteLog(LogLevel.Critical, LogType.GeneralConfigFailure, "Failed to load rules. Exiting.", ClassLogCode);
                    return;
                }
            }

            if (Global.Settings.LoadKIDConfigs)
            {
                int configFile = Rules.Count != 0 ? Rules.Max(r => r.ConfigFile) : 1;
                var loader = new GenericSynthesisPatcher.Rules.Loaders.KID.KidLoader();
                Loaders.Add(loader);

                if (loader.LoadRules(configFile))
                    Rules.AddRange(loader.Rules);
            }

            bool result = RunPatch(Rules);

            Global.Logger.StartNewBlock();

            foreach (var loader in Loaders)
                loader.Close(result);

            Global.Logger.WriteRawBlock(Global.Logger.GetCounts());

            if (result)
            {
                Global.Logger.WriteRawLine("Record Type Totals");
                Global.Logger.WriteRawLine($"{"Type",-15} {"Total",10} {"Matched",10} {"Updated",10} {"Changes",10}");

                var totals = new Counts();
                TimeSpan ts = new();

                foreach (var (key, subTotal) in SubTotals)
                {
                    if (Global.Settings.Logging.LogLevel == LogLevel.Trace)
                        Global.Logger.WriteRawLine($"{key,-15} {subTotal.Total,10:N0} {subTotal.Matched,10:N0} {subTotal.Updated,10:N0} {subTotal.Changes,10:N0}   {subTotal.Stopwatch.Elapsed:c}");
                    else
                        Global.Logger.WriteRawLine($"{key,-15} {subTotal.Total,10:N0} {subTotal.Matched,10:N0} {subTotal.Updated,10:N0} {subTotal.Changes,10:N0}");

                    totals.Total += subTotal.Total;
                    totals.Matched += subTotal.Matched;
                    totals.Updated += subTotal.Updated;
                    totals.Changes += subTotal.Changes;
                    ts = ts.Add(subTotal.Stopwatch.Elapsed);
                }

                if (Global.Settings.Logging.LogLevel == LogLevel.Trace)
                    Global.Logger.WriteRawLine($"{"Totals",-15} {totals.Total,10:N0} {totals.Matched,10:N0} {totals.Updated,10:N0} {totals.Changes,10:N0}   {ts:c}");
                else
                    Global.Logger.WriteRawLine($"{"Totals",-15} {totals.Total,10:N0} {totals.Matched,10:N0} {totals.Updated,10:N0} {totals.Changes,10:N0}");
            }
        }

        public static bool RunPatch (List<GSPBase> Rules)
        {
            if (Rules.Count == 0)
            {
                Global.Logger.WriteLog(LogLevel.Critical, LogType.GeneralConfigFailure, "No rules loaded. Exiting.", ClassLogCode);
                return false;
            }

            HashSet<ILoquiRegistration> EnabledTypes = [.. Rules.SelectMany(r => r.Types)];

            int groupCount = Rules.Count(r => r is GSPGroup);
            int ruleCount = Rules.Count - groupCount;

            if (groupCount != 0)
            {
                int groupRuleCount = Rules.Sum(r => r is GSPGroup group ? group.Rules.Count : 0);
                Global.Logger.WriteLog(LogLevel.Information, LogType.GeneralConfig, $"Rules: {ruleCount} Groups: {groupCount} Group Rules: {groupRuleCount}", ClassLogCode);
            }
            else
            {
                Global.Logger.WriteLog(LogLevel.Information, LogType.GeneralConfig, $"Loaded {ruleCount} rules.", ClassLogCode);
            }

            foreach (var rtm in EnabledTypes)
            {
                var ruleFinder = new RuleFinder();
                ruleFinder.AddRules(Rules.Where(r => r.Types.Contains(rtm)));

                ruleFinder.PrintStats(Global.Logger);

                var ProcessTypeRecords = Global.Game.GetRecords(rtm);
                var counts = new Counts();
                SubTotals.Add(rtm.Name, counts);

                counts.Stopwatch.Start();
                foreach (var context in ProcessTypeRecords)
                {
                    counts.Total++;
                    var proKeys = new ProcessingKeys(context);

                    var currentRules = ruleFinder.Rules(proKeys);

                    foreach (var rule in currentRules)
                    {
                        Global.Logger.UpdateCurrentProcess(rule, context, ClassLogCode);

                        _ = proKeys.SetRule(rule);
                        int changed = rule.RunActions(proKeys);
                        if (changed >= 0) // -1 would mean failed OnlyIfDefault check
                        {
                            counts.Matched++;
                            if (changed > 0)
                                counts.Updated++;
                            counts.Changes += changed;
                        }
                    }
                }

                counts.Stopwatch.Stop();
            }

            Global.Logger.UpdateCurrentProcess(null, null, ClassLogCode);
            Global.Logger.DefaultLogLevel = LogLevel.Information;
            Global.Logger.WriteRawLine("Completed");

            Global.Logger.StartNewBlock();

            var updates = RecordUpdates.GroupBy(g => (g.Type, g.FormKey, g.Property),
                                                g => (g.Rule, g.Changes), (k, data) => new { Key = k, Rules = data.Select(d => d.Rule).Count(), Changes = data.Select(d => d.Changes).Sum() })
                                       .Where(g => g.Rules > 1);

            foreach (var update in updates)
                Global.Logger.WriteLog(LogLevel.Information, LogType.CONFIG, $"Record {update.Key.FormKey} had {update.Key.Property} updated by {update.Rules} different rules, with total of {update.Changes} changes.", ClassLogCode);

            Global.Logger.StartNewBlock();

            return true;
        }
    }
}