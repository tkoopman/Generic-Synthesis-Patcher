using EnumsNET;
using GenericSynthesisPatcher.Helpers;
using GenericSynthesisPatcher.Json.Data;
using Microsoft.Extensions.Logging;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda;
using Newtonsoft.Json;
using Noggog;
using System.Data;
using Mutagen.Bethesda.Plugins.Order;
using DynamicData;
using System.Diagnostics.Metrics;
using NexusMods.Paths.Trees.Traits;
using GenericSynthesisPatcher.Helpers.Action;
using System.Reflection.Metadata.Ecma335;
using System.Text.RegularExpressions;

namespace GenericSynthesisPatcher
{
    // Log Codes: 0x0xx
    public class Program
    {
        public static async Task<int> Main ( string[] args ) => await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(nickname: "Generic Synthesis Patcher Settings", path: "settings.json", out Global.settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "GenericSynthesisPatcher.esp")
                .Run(args);

        // Log Codes: 0x00x
        public static void RunPatch ( IPatcherState<ISkyrimMod, ISkyrimModGetter> state )
        {
            Global.State = state;

            var Rules = LoadRules();
            if ( Rules.Count == 0 ) 
                return;

            uint total = 0, updated = 0, changes = 0;
            SortedDictionary<string, (uint, uint, uint)> subTotals = [];

            foreach (var context in state.LoadOrder.PriorityOrder.SkyrimMajorRecord().WinningContextOverrides(state.LinkCache))
            {
                string recordType = GSPRule.GetGSPRuleTypeAsString(context.Record);
                if (!subTotals.ContainsKey(recordType))
                    subTotals.Add(recordType, (0, 0, 0));
                subTotals[recordType] = (subTotals[recordType].Item1 + 1, subTotals[recordType].Item2, subTotals[recordType].Item3);

                total++;
                Rules.ForEach(rule =>
                {
                    if (rule.Matches(context, out var origin))
                    {
                        subTotals[recordType] = (subTotals[recordType].Item1, subTotals[recordType].Item2 + 1, subTotals[recordType].Item3);

                        bool recordUpdated = false;
                        foreach (var x in rule.jsonValues ?? [])
                        {
                            switch (x.Key.ActionType)
                            {
                                case GSPRule.ActionType.Fill:
                                    if (FillRecord(context, origin, rule, x.Key))
                                    {
                                        changes++;
                                        recordUpdated = true;
                                    }

                                    break;
                                case GSPRule.ActionType.Forward:
                                    uint changed = ForwardRecord(context, origin, rule, x.Key);
                                    changes += changed;
                                    if (changed > 0)
                                        recordUpdated = true;

                                    break;
                                default:
                                    LogHelper.Log(LogLevel.Warning, context, "Unknown action type", 0x001);
                                    break;
                            }
                        }

                        if (recordUpdated)
                        {
                            subTotals[recordType] = (subTotals[recordType].Item1, subTotals[recordType].Item2, subTotals[recordType].Item3 + 1);
                            updated++;
                        }
                    }
                });
            }

            LogHelper.Log(LogLevel.Information, $"Completed. Applied {changes:N0} changes to {updated:N0} of {total:N0} records.");

            Console.WriteLine($"Record Type Totals");
            Console.WriteLine($"{"Type",-10} {"Total",10} {"Matched",10} {"Updated",10}");
            foreach (var t in subTotals)
                Console.WriteLine($"{t.Key,-10} {t.Value.Item1,10:N0} {t.Value.Item2,10:N0} {t.Value.Item3,10:N0}");
        }
        private static List<GSPRule> LoadRules ()
        {
            string dataFolder = Global.Settings.Value.Folder;
            dataFolder = dataFolder.Replace("{SkyrimData}", Global.State.DataFolderPath);
            dataFolder = dataFolder.Replace("{SynthesisData}", Global.State.ExtraSettingsDataPath);

            if (!Directory.Exists(dataFolder))
            {
                LogHelper.Log(LogLevel.Error, $"Missing data folder: {dataFolder}");
                return [];
            }

            var rules = new List<GSPRule>();

            var files = Directory.GetFiles(dataFolder).Where(x => x.EndsWith(".json"));
            files.ForEach(f =>
            {
                if (Path.Combine(dataFolder, f).Equals(Path.Combine(Global.State.ExtraSettingsDataPath ?? "", "settings.json")))
                {
                    LogHelper.Log(LogLevel.Information, $"Skipping: {Path.Combine(dataFolder, f)}");
                }
                else
                {
                    LogHelper.Log(LogLevel.Information, $"Loading config file: {Path.Combine(dataFolder, f)}");
                    var a = JsonConvert.DeserializeObject<List<GSPRule>>(File.ReadAllText(Path.Combine(dataFolder, f)), Global.SerializerSettings);
                    rules = [.. rules, .. a];
                }
            });

            if (rules.Count == 0)
            {
                LogHelper.Log(LogLevel.Error, $"No rules found in data location: {dataFolder}");
                return [];
            }

            rules.Sort(delegate ( GSPRule rule1, GSPRule rule2 )
            {
                return rule1.Priority == rule2.Priority
                        ? rule1.Types != null && rule2.Types == null
                            ? 1 : rule1.Types == null && rule2.Types != null
                            ? -1 : (rule1.Types == null && rule2.Types == null) || (rule1.Types?.Count == rule2.Types?.Count)
                            ? rule1.FormID != null && rule2.FormID == null
                                ? 1 : rule1.FormID == null && rule2.FormID != null
                                ? -1 : (rule1.FormID == null && rule2.FormID == null) || (rule1.FormID?.Count == rule2.FormID?.Count)
                                ? rule1.EditorID != null && rule2.EditorID == null
                                    ? 1 : rule1.EditorID == null && rule2.EditorID != null
                                    ? -1 : rule1.EditorID?.Count.CompareTo(rule2.EditorID?.Count) ?? 0
                                : rule1.FormID?.Count.CompareTo(rule2.FormID?.Count) ?? 0
                            : rule1.Types?.Count.CompareTo(rule2.Types?.Count) ?? 0
                        : rule1.Priority.CompareTo(rule2.Priority);
            });

            LogHelper.Log(LogLevel.Information, $"Loaded {rules.Count} rules");

            return rules;
        }

        // Log Code: 0x01x
        public static bool FillRecord ( IModContext<ISkyrimMod, ISkyrimModGetter, ISkyrimMajorRecord, ISkyrimMajorRecordGetter> context, IMajorRecordGetter? origin, GSPRule rule, GSPRule.ValueKey valueKey )
        {
            if (context.Record is not IMajorRecordGetter)
            {
                LogHelper.LogInvalidTypeFound(LogLevel.Trace, context, "", typeof(IMajorRecordGetter).Name, context.Record.GetType().Name, 0x011);
                return false;
            }
            
            switch (valueKey.Key.ToLower())
            {
                case "damage":
                case "dmg":
                    return Generic.Fill<float>(context, origin, rule, valueKey, "Damage");
                case "desc":
                case "description":
                    return Helpers.Action.String.FillString(context, origin, rule, valueKey, "Description");
                case "effects":
                    return Effects.FillEffects(context, origin, rule, valueKey, "Effects");
                case "enchantmentamount":
                case "eamt":
                    return Generic.Fill<ushort>(context, origin, rule, valueKey, "EnchantmentAmount");
                case "objecteffect":
                case "eitm":
                    return FormLink.FillFormLink<IEffectRecordGetter>(context, origin, rule, valueKey, "ObjectEffect");
                case "flags":
                    return Flags.FillFlags(context, origin, rule, valueKey, "Flags");
                case "items":
                    return FormLink.FillFormLinks<IOutfitTargetGetter>(context, origin, rule, valueKey, "Items");
                case "kwda":
                case "keywords":
                    return Helpers.Action.Keyword.FillKeywords(context, origin, rule, valueKey, "Keywords");
                case "location":
                case "xlcn":
                    return FormLink.FillFormLink<ILocationGetter>(context, origin, rule, valueKey, "Location");
                case "majorflags":
                    return Flags.FillFlags(context, origin, rule, valueKey, "MajorFlags");
                case "full":
                case "name":
                    return Helpers.Action.String.FillString(context, origin, rule, valueKey, "Name");
                case "value":
                    return Generic.Fill<uint>(context, origin, rule, valueKey, "Value");
                case "weight":
                    return Generic.Fill<float>(context, origin, rule, valueKey, "Weight");
                case "water":
                case "xcwt":
                    return FormLink.FillFormLink<IWaterGetter>(context, origin, rule, valueKey, "Water");
                default:
                    LogHelper.Log(LogLevel.Trace, context, $"Unknown / Unimplemented field for fill action: {valueKey.Key}", 0x012);
                    break;
            }

            return false;
        }

        // Log Code: 0x02x
        public static uint ForwardRecord ( IModContext<ISkyrimMod, ISkyrimModGetter, ISkyrimMajorRecord, ISkyrimMajorRecordGetter> context, IMajorRecordGetter? origin, GSPRule rule, GSPRule.ValueKey valueKey )
        {
            if (context.Record is not IMajorRecordGetter)
            {
                LogHelper.LogInvalidTypeFound(LogLevel.Trace, context, "", typeof(IMajorRecordGetter).Name, context.Record.GetType().Name, 0x021);
                return 0;
            }

            var forwardRecord = Mod.GetModRecord(context, valueKey.Key);
            if (forwardRecord == null)
            {
                //LogHelper.Log(LogLevel.Trace, context, "No forwarding record.", 0x022);
                return 0;
            }

            var forwardFields = rule.GetValueAs<List<string>>(valueKey);
            if (forwardFields == null || forwardFields.Count == 0)
            {
                LogHelper.Log(LogLevel.Trace, context, "No fields in config to forward", 0x023);
                return 0;
            }

            uint changed = 0;
            foreach (string forwardField in forwardFields)
            {
                switch (forwardField.ToLower())
                {
                    case "damage":
                    case "dmg":
                        if (Generic.Forward<float>(context, origin, rule, forwardRecord, "Damage"))
                            changed++;
                        break;
                    case "desc":
                    case "description":
                        if (Helpers.Action.String.ForwardString(context, origin, rule, forwardRecord, "Description"))
                            changed++;
                        break;
                    case "effects":
                        if (Effects.ForwardEffects(context, origin, rule, forwardRecord, "Effects"))
                            changed++;
                        break;
                    case "enchantmentamount":
                    case "eamt":
                        if (Generic.Forward<ushort>(context, origin, rule, forwardRecord, "EnchantmentAmount"))
                            changed++;
                        break;
                    case "objecteffect":
                    case "eitm":
                        if (FormLink.ForwardFormLink<IEffectRecordGetter>(context, origin, rule, forwardRecord, "ObjectEffect"))
                            changed++;
                        break;
                    case "items":
                        if (FormLink.ForwardFormLinks<IOutfitTargetGetter>(context, origin, rule, forwardRecord, "Items"))
                            changed++;
                        break;
                    case "keywords":
                        if (Helpers.Action.Keyword.ForwardKeywords(context, origin, rule, forwardRecord, "Keywords"))
                            changed++;
                        break;
                    case "location":
                    case "xlcn":
                        if (FormLink.ForwardFormLink<ILocationGetter>(context, origin, rule, forwardRecord, "Location"))
                            changed++;
                        break;
                    case "full":
                    case "name":
                        if (Helpers.Action.String.ForwardString(context, origin, rule, forwardRecord, "Name"))
                            changed++;
                        break;
                    case "value":
                        if (Generic.Forward<uint>(context, origin, rule, forwardRecord, "Value"))
                            changed++;
                        break;
                    case "weight":
                        if (Generic.Forward<float>(context, origin, rule, forwardRecord, "Weight"))
                            changed++;
                        break;
                    case "water":
                    case "xcwt":
                        if (FormLink.ForwardFormLink<IWaterGetter>(context, origin, rule, forwardRecord, "Water"))
                            changed++;
                        break;
                    default:
                        LogHelper.Log(LogLevel.Trace, context, $"Unknown / Unimplemented field for forward action: {forwardField}", 0x024);
                        break;
                }
            }

            return changed;
        }
    }
}
