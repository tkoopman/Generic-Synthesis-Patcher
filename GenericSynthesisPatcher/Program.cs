using System.Data;

using GenericSynthesisPatcher.Games.Universal;
using GenericSynthesisPatcher.Helpers;
using GenericSynthesisPatcher.Rules;
using GenericSynthesisPatcher.Rules.Loaders;

using Loqui;

using Microsoft.Extensions.Logging;

using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Synthesis;

namespace GenericSynthesisPatcher
{
    public partial class Program
    {
        /// <summary>
        ///     Record of all record properties that have been updated. Used to detect when a
        ///     property is updated by 2 different processes.
        /// </summary>
        internal static readonly List<(ILoquiRegistration Type, FormKey FormKey, GSPRule Rule, PropertyAction Property, int Changes)> RecordUpdates = [];

        private const int ClassLogCode = 0x01;

        public static async Task<int> Main (string[] args)
        {
            if (args.Length == 0)
                return -1;

            //TODO Add games
            return await SynthesisPipeline.Instance
                                .AddPatch<Mutagen.Bethesda.Skyrim.ISkyrimMod, Mutagen.Bethesda.Skyrim.ISkyrimModGetter>(RunPatch)
                                .AddPatch<Mutagen.Bethesda.Fallout4.IFallout4Mod, Mutagen.Bethesda.Fallout4.IFallout4ModGetter>(RunPatch)
                                .AddPatch<Mutagen.Bethesda.Oblivion.IOblivionMod, Mutagen.Bethesda.Oblivion.IOblivionModGetter>(RunPatch)
                                .SetAutogeneratedSettings(nickname: "Generic Synthesis Patcher Settings", path: "settings.json", out Global.LazySettings)
                                .SetTypicalOpen(GameRelease.SkyrimSE, "GenericSynthesisPatcher.esp")
                                .Run(args);
        }

        public static void RunPatch (IPatcherState<Mutagen.Bethesda.Skyrim.ISkyrimMod, Mutagen.Bethesda.Skyrim.ISkyrimModGetter> state)
        {
            Global.Initialize(state);
            RunPatch();
        }

        public static void RunPatch (IPatcherState<Mutagen.Bethesda.Fallout4.IFallout4Mod, Mutagen.Bethesda.Fallout4.IFallout4ModGetter> state)
        {
            Global.Initialize(state);
            RunPatch();
        }

        public static void RunPatch (IPatcherState<Mutagen.Bethesda.Oblivion.IOblivionMod, Mutagen.Bethesda.Oblivion.IOblivionModGetter> state)
        {
            Global.Initialize(state);
            RunPatch();
        }

        public static void RunPatch ()
        {
            if (Global.Settings.Logging.LogLevel <= LogLevel.Debug)
            {
                Global.Logger.WriteLog(LogLevel.Debug, LogType.GeneralConfig, "Extra logging for FormKey: " +
                    (
                        Global.Settings.Logging.All ? "ALL" :
                        Global.Settings.Logging.FormKey == FormKey.Null ? "None" :
                        Global.Settings.Logging.FormKey.ToString()
                    ), ClassLogCode);
            }

            List<GSPBase> Rules = [];
            if (!GSPJson.TryLoadRules(1, out var rules))
            {
                Global.Logger.WriteLog(LogLevel.Critical, LogType.GeneralConfigFailure, "Failed to load rules. Exiting.", ClassLogCode);
                return;
            }

            Rules.AddRange(rules);

            if (Rules.Count == 0)
            {
                Global.Logger.WriteLog(LogLevel.Critical, LogType.GeneralConfigFailure, "No rules loaded. Exiting.", ClassLogCode);
                return;
            }

            Rules.Sort();

            HashSet<ILoquiRegistration> EnabledTypes = [.. Rules.SelectMany(r => r.Types)];

            int groupCount = Rules.Count(r => r is GSPGroup);
            int ruleCount = Rules.Count - groupCount;

            if (groupCount > 0)
            {
                int groupRuleCount = Rules.Sum(r => r is GSPGroup group ? group.Rules.Count : 0);
                Global.Logger.WriteLog(LogLevel.Information, LogType.GeneralConfig, $"Rules: {ruleCount} Groups: {groupCount} Group Rules: {groupRuleCount}", ClassLogCode);
            }
            else
            {
                Global.Logger.WriteLog(LogLevel.Information, LogType.GeneralConfig, $"Loaded {ruleCount} rules.", ClassLogCode);
            }

            // subTotals values = (Total, Matched, Updated, Changes)
            SortedDictionary<string, Counts> subTotals = [];

            foreach (var rtm in EnabledTypes)
            {
                var ProcessTypeRecords = Global.Game.GetRecords(rtm);
                var counts = new Counts();
                subTotals.Add(rtm.Name, counts);

                counts.Stopwatch.Start();
                foreach (var context in ProcessTypeRecords)
                {
                    counts.Total++;
                    var proKeys = new ProcessingKeys(context);

                    foreach (var rule in Rules)
                    {
                        Global.Logger.UpdateCurrentProcess(rule, context, ClassLogCode);

                        _ = proKeys.SetRule(rule);

                        if (rule.Matches(proKeys))
                        {
                            int changed = rule.RunActions(proKeys);
                            if (changed >= 0) // -1 would mean failed OnlyIfDefault check
                            {
                                counts.Matched++;
                                if (changed > 0)
                                    counts.Updated++;
                                counts.Changes += changed;
                            }
                        }
                    }
                }

                counts.Stopwatch.Stop();
            }

            Global.Logger.UpdateCurrentProcess(null, null, ClassLogCode);
            Global.Logger.DefaultLogLevel = LogLevel.Information;
            Global.Logger.Out.WriteLine("Completed");
            Global.Logger.Out.WriteLine();
            Global.Logger.PrintCounts();
            Global.Logger.Out.WriteLine();

            var updates = RecordUpdates.GroupBy(g => (g.Type, g.FormKey, g.Property.PropertyName),
                                                g => (g.Rule, g.Changes), (k, data) => new { Key = k, Rules = data.Select(d => d.Rule).Count(), Changes = data.Select(d => d.Changes).Sum() })
                                       .Where(g => g.Rules > 1);

            foreach (var update in updates)
                Global.Logger.Out.WriteLine($"Warning: Record {update.Key.FormKey} had {update.Key.PropertyName} updated by {update.Rules} different rules, with total of {update.Changes} changes.");

            Global.Logger.Out.WriteLine();

            Global.Logger.Out.WriteLine("Record Type Totals");
            Global.Logger.Out.WriteLine($"{"Type",-15} {"Total",10} {"Matched",10} {"Updated",10} {"Changes",10}");

            var totals = new Counts();
            TimeSpan ts = new();

            foreach (var (key, subTotal) in subTotals)
            {
                if (Global.Settings.Logging.LogLevel == LogLevel.Trace)
                    Global.Logger.Out.WriteLine($"{key,-15} {subTotal.Total,10:N0} {subTotal.Matched,10:N0} {subTotal.Updated,10:N0} {subTotal.Changes,10:N0}   {subTotal.Stopwatch.Elapsed:c}");
                else
                    Global.Logger.Out.WriteLine($"{key,-15} {subTotal.Total,10:N0} {subTotal.Matched,10:N0} {subTotal.Updated,10:N0} {subTotal.Changes,10:N0}");

                totals.Total += subTotal.Total;
                totals.Matched += subTotal.Matched;
                totals.Updated += subTotal.Updated;
                totals.Changes += subTotal.Changes;
                ts = ts.Add(subTotal.Stopwatch.Elapsed);
            }

            if (Global.Settings.Logging.LogLevel == LogLevel.Trace)
                Global.Logger.Out.WriteLine($"{"Totals",-15} {totals.Total,10:N0} {totals.Matched,10:N0} {totals.Updated,10:N0} {totals.Changes,10:N0}   {ts:c}");
            else
                Global.Logger.Out.WriteLine($"{"Totals",-15} {totals.Total,10:N0} {totals.Matched,10:N0} {totals.Updated,10:N0} {totals.Changes,10:N0}");
        }
    }
}