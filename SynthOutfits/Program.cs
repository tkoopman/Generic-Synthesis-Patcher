using System.Globalization;

using CsvHelper;

using GSPShared;

using Mutagen.Bethesda;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

using Noggog;

namespace SynthOutfits
{
    public partial class Program
    {
        internal static Lazy<Settings> Settings = null!;
        internal static IPatcherState<ISkyrimMod, ISkyrimModGetter> State = null!;

        private static readonly CsvHelper.Configuration.CsvConfiguration csvConfig = new(CultureInfo.InvariantCulture)
        {
            HasHeaderRecord = false,
            Delimiter = "\t",
            DetectDelimiter = true,
            TrimOptions = CsvHelper.Configuration.TrimOptions.Trim,
            IgnoreBlankLines = true,
            BadDataFound = null,
            AllowComments = true,
            Comment = '#',
        };

        private static JsonConfig jsonConfig = null!;
        private static uint nextFormID = 0;
        private static FilePath spidFile;
        public static UVDictionary<uint, string> FormIDCache { get; set; } = new(null, StringComparer.OrdinalIgnoreCase);

        public static uint GetFormID (string editorID)
        {
            if (FormIDCache.TryGetKey(editorID, out uint formID))
            {
                return formID;
            }
            else
            {
                uint id = nextFormID++;
                return FormIDCache.TryAdd(id, editorID) ? id : throw new InvalidDataException($"Failed to add outfit {editorID} ({id}) to cache");
            }
        }

        public static async Task<int> Main (string[] args) => await SynthesisPipeline.Instance
            .SetAutogeneratedSettings(nickname: "SynthOutfits Settings", path: "settings.json", out Settings)
            .AddRunnabilityCheck(loadConfigAndCheckRunnability)
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetTypicalOpen(GameRelease.SkyrimSE, "SynthOutfits.esp")
            .Run(args);

        public static void RunPatch (IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            State = state;
            if (State.PatchMod.NextFormID != 0)
                throw new InvalidOperationException("SynthOutfits must be the first patch in a Synthesis' Group.");

            loadFormIDCache();
            if (Settings.Value.UpdateCache)
                generateFormIDCache();

            Console.WriteLine($"Loaded {FormIDCache.Count} outfits from cache");
            nextFormID = (FormIDCache.Keys.Count == 0) ? State.PatchMod.NextFormID : FormIDCache.Keys.Max() + 1;

            createLeveledItems();
            createOutfits();

            writeFormIDCache();
        }

        private static void createLeveledItems ()
        {
            foreach (var jsonLeveledItem in jsonConfig.LeveledItems)
            {
                var lvlItem = jsonLeveledItem.ToLeveledItem();

                if (lvlItem is not null)
                {
                    State.PatchMod.LeveledItems.Add(lvlItem);
                    Console.WriteLine($"Added LeveledItem: {lvlItem.EditorID} [{lvlItem.FormKey}]");
                }
            }
        }

        /// <summary>
        ///     Creates and assigns outfits to NPCs.
        /// </summary>
        private static void createOutfits ()
        {
            using var writer = new StreamWriter(spidFile, false);
            writer.WriteLine("; Generated by SynthOutfits");
            writer.WriteLine();

            foreach (var jsonOutfit in jsonConfig.Outfits)
            {
                var outfit = jsonOutfit.ToOutfit();

                if (outfit is not null)
                {
                    State.PatchMod.Outfits.Add(outfit);
                    Console.WriteLine($"Added outfit: {outfit.EditorID} [{outfit.FormKey}]");

                    foreach (string npcOutfit in jsonOutfit.DefaultOutfit)
                    {
                        if (Common.TryGetRecordContext<INpc, INpcGetter>(npcOutfit, State.LinkCache, out var context))
                        {
                            var patchRecord = context.GetOrAddAsOverride(State.PatchMod);
                            patchRecord.DefaultOutfit = outfit.ToNullableLink();

                            Console.WriteLine($"    Added as DefaultOutfit to {patchRecord.Name} [{patchRecord.FormKey}]");
                        }
                        else
                        {
                            Console.WriteLine($"    Failed to add as DefaultOutfit to {npcOutfit}");
                        }
                    }

                    foreach (string npcOutfit in jsonOutfit.SleepingOutfit)
                    {
                        if (Common.TryGetRecordContext<INpc, INpcGetter>(npcOutfit, State.LinkCache, out var context))
                        {
                            var patchRecord = context.GetOrAddAsOverride(State.PatchMod);
                            patchRecord.SleepingOutfit = outfit.ToNullableLink();

                            Console.WriteLine($"    Added as SleepingOutfit to {patchRecord.Name} [{patchRecord.FormKey}]");
                        }
                        else
                        {
                            Console.WriteLine($"    Failed to add as SleepingOutfit to {npcOutfit}");
                        }
                    }

                    foreach (string spid in jsonOutfit.SPID)
                    {
                        writer.WriteLine($"Outfit = 0x{outfit.FormKey.ID:X}~{outfit.FormKey.ModKey}|{spid}");
                    }
                }
            }
        }

        /// <summary>
        ///     Update loaded FormID cache with entries from the current version of this patcher's
        ///     mod. Should override any existing EditorID entries with the new FormID.
        /// </summary>
        private static void generateFormIDCache ()
        {
            var path = State.DataFolderPath.GetFile(State.OutputPath.Name);

            if (!path.Exists)
            {
                Console.WriteLine($"Could not find mod: {path.Name}");
                return;
            }

            Console.WriteLine($"Attempting to generate output cache from {path.Name}");

            var mod = SkyrimMod.CreateFromBinary(path, State.GameRelease.ToSkyrimRelease());

            foreach (var record in mod.EnumerateMajorRecords())
            {
                if (record.EditorID.IsNullOrWhitespace() || !record.FormKey.ModKey.Equals(mod.ModKey))
                    continue;

                if (!FormIDCache.TryUpdateOrAdd(record.FormKey.ID, record.EditorID))
                    throw new InvalidDataException($"Failed to add outfit {record.EditorID} ({record.FormKey}) to cache");
            }
        }

        /// <summary>
        ///     Load and check the validity of the configuration files. Doesn't check for listed
        ///     EditorIDs or FormKeys actually existing, just that the config file format is
        ///     correct.Should throw exception if any issues are found to stop Synthesis from
        ///     starting the actual patch run, as this a Runnability Check for this patcher.
        /// </summary>
        private static void loadConfigAndCheckRunnability (IRunnabilityState state)
        {
            jsonConfig = new JsonConfig();

            jsonConfig.LoadConfigurationFiles(state);

            DirectoryPath spidDir = string.IsNullOrWhiteSpace(Settings.Value.Output) ? state.DataFolderPath : Settings.Value.Output;
            if (!spidDir.Exists)
                throw new FileNotFoundException("Unable to find output path.", spidDir);

            spidFile = spidDir.GetFile($"{state.ExtraSettingsDataPath?.Name.NameWithoutExtension}_DISTR.ini");

            Console.WriteLine($"SPID output file: {spidFile}");
        }

        /// <summary>
        ///     Loads the FormID cache from the CSV data file saved in previous runs.
        /// </summary>
        private static void loadFormIDCache ()
        {
            if (State.ExtraSettingsDataPath is null)
                return;

            string path = Path.Combine(State.ExtraSettingsDataPath, "formIDCache.txt");

            if (!Path.Exists(path))
            {
                Console.WriteLine($"Could not find outfit cache: {path}");
                return;
            }

            Console.WriteLine($"Loading outfit cache from {path}");

            using (var reader = new StreamReader(path))
            using (var csv = new CsvReader(reader, csvConfig))
            {
                while (csv.Read())
                {
                    _ = csv.TryGetField(0, out int key) && csv.TryGetField(1, out string? value) && !string.IsNullOrWhiteSpace(value)
                        ? FormIDCache.TryAdd((uint)key, value)
                        : throw new InvalidDataException("FormID cache contains invalid entry.\n" + csv.Parser.RawRow);
                }
            }
        }

        private static void writeFormIDCache ()
        {
            if (State.ExtraSettingsDataPath is null)
                return;

            if (!Path.Exists(State.ExtraSettingsDataPath))
            {
                Console.WriteLine($"Could not find data folder: {State.ExtraSettingsDataPath}");
                return;
            }

            string path = Path.Combine(State.ExtraSettingsDataPath, "formIDCache.txt");

            Console.WriteLine($"Writing outfit cache to {path}");
            using (var writer = new StreamWriter(path, false))
            using (var csv = new CsvWriter(writer, csvConfig))
            {
                foreach (var entry in FormIDCache)
                {
                    csv.WriteField(entry.Key);
                    csv.WriteField(entry.Value);
                    csv.NextRecord();
                }
            }
        }
    }
}